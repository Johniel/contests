# Educational DP Contest: W Intervals

[問題文](https://atcoder.jp/contests/dp/tasks/dp_w)

```
dp[i][j] = i番目の文字までを決めていて、最後の1がj番目であるような場合の最大値
```
もし仮に上記のようなDPを考えると

```
 // f(i, j) は、始点がj以降でiを含むような区間のスコアの合計を返す関数
 for (int i = 0; i < n; ++i) {
    for (int j = 0; j < i; ++j) {
      dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
      dp[i + 1][i] = max(dp[i + 1][i], dp[i][j] + f(i, j));
    }
  }
```
といった風になってO(N^2)で間に合わない。

---

1. dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
2. dp[i + 1][i] = max(dp[i + 1][i], dp[i][j] + f(i, j));

1つ目の式はただのコピーなので、領域を使いまわして１次元にするとして、２つ目が問題になる。
ある位置kに1を立てたとしても獲得できるスコアがそれだけでは決まらない。
※直前に1を立てた位置とkの両方を含むような区間のスコアを重複して獲得しうるため。

なので、
```
dp[i] = i番目の文字が決まっている場合の最大値
```
といった解き方はできない。

---

kを含むような区間のスコアを足せるのか分からないから困るのであって、区間の終端時点でまとめて足してしまって最大値を探すように変えれば良い。

```
dp[i]= 位置iまでに終端がある区間を全て試した場合の最大値
```
としてみる。

```
dp[i + 1] = max({dp[0], ... dp[i]});
// ajはiを終端とする区間jのスコアで、kは区間jに含まれる。
dp[k] += aj;
```
ある区間に含まれる位置全てを更新しながら決めていくことをイメージすると良いのかもしれない。

これらは、
+ 区間に対するmax
+ 区間に対するadd
+ １カ所の更新

があれば実現できるので区間に対する操作をO(log N)で可能なデータ構造（遅延セグメント木等)を使って解ける。

