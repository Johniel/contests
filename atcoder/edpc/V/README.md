# EDPC: V

まず頂点0を根としてパターン数を数える。次にその結果を使いまわしつつ頂点0から再帰して別の頂点の分も数えていく。

全方位木DPと言われているアプローチ。老害には難しい。

## 頂点0を根に黒く塗るパターン数を考える

黒だけを辿って全ての黒に到達可能ということは、一度白に塗ったらそれより下は全て白になるということ。

+ 黒に塗る場合: 子の塗り方の総乗
+ 白に塗る場合: 1通り

なので、

```
f(i) := Π(f(j) + 1) // (i,j)∈E
```

これは `O(N)` で終わる。DFSは `O(V+E)` だが木は `V=E-1` なので線形時間。

## 使い回して別の頂点を考える

頂点0とまったく同じことをしていては `O(N^2)` で間に合わない。

まず、xを根にした場合は分かっていてw-x-y-zというパスが存在したとしたとする。

次にxから遷移してyを根にした場合を考えたい。y→zについてはxを根にしたときに既に数えているので使い回せる。

残りはy→xの塗り方さえ知れれば良いのだが、これはxからyに遷移するときに引数として渡してやる。関数宣言はこんな風↓

```
fn(注目している頂点x,親の頂点y,xを親としてyを塗るパターン数)
```

yを根とした場合のパターン数の計算に必要な値のうち、y→xの分は渡して、残りはxを根にしたときに数えている。

`xを親としてyを塗るパターン数` を毎回計算していては間に合わないが、累積積を使って総乗の計算からx→yの分を取り除けば計算できる。

つまり、v0がv1〜vnを子に持つ場合に、

+ L[i] = v1からi番目の頂点までの塗り方の総乗
+ R[i] = vnからi番目の頂点までの塗り方の総乗

とした場合にj番目の頂点以外の総乗は、 `L[j] * R[j + 1]` で計算できる※半開区間

これは前計算全体でも `O(E)` になる。遷移は `O(V)` なので全体で `O(N)` となる。
