# [codeforces710div3G](https://codeforces.com/contest/1506/problem/G)

## "2021-04-24 19-05-44"
与えられる文字列sに複数回出現する文字それぞれを１つだけ残して消すといった操作を繰り返して作れる文字列tで辞書順最大のモノを出力せよ。
+ 一度に与えられるテストケース数<=1e4
+ |s|<=2*1e5
+ 例として、s=codeforcesならt=odfrces

辞書順{最大,最小}は頭から貪欲と相場が決まっている。
しかし、zやaならまだしも他の文字は必ずしも前寄り/後ろ寄りを選択するとはならない気がする。
abcabcabcならcbaで、bは真ん中に出現するものを残す方が最適。

|t|がアルファベット長にしかならないのなら、tに含まれない文字のうち最大のもとのを順番に追加可能か検証するだけでは？
検証するコストの(26^2)倍くらいで実行できそう。

インデックス毎にある文字が次に出現する位置を覚えておけば良い？
後ろから順番に決定していくような動的計画法を考えて、 `dp[何文字目まで決めた][この次の文字]:=作れるtの長さ1` なんかでどう？
これだと２度同じ文字を使いそう。駄目。

いや、26文字しか無いし、次にある文字を加えたとして残りの文字も全て追加可能か判定することが容易なんじゃ？

サンプルが合わない。

普通に実装を間違っていた。もう一度。

RE。定数を間違っている。駄目じゃん。もう一度。

それでもRE。定数を間違っている。数分ぶり２度目。テストケース数と文字列長を取り違えるって何？

無事AC。本番で解けても良い内容だった。
