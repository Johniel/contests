# Educational Codeforces Round 107 D
## "2021-04-25 01-14-06"
文字列sで `s[i]==s[j] && s[i+1]==s[j+1]` となるようなインデックスの個数を文字列のコストとする。
nとkが与えられる。aからk種類までのアルファベットを用いてコストが最小になるような長さnの文字列を１つ出力する。

+ n<=2*1e5
+ k<=26

文字列sで隣接する２文字の組の出現回数を抑えればコストも下がる。
26^2よりnが大きくなる場合は同じ文字列を繰り返せば大丈夫でしょきっと。
長ければ削るということで。

アルファベットを頂点、隣接する２文字を辺だと見なして、k頂点の完全グラフで同じ辺を使わないようにして作れる最長のパスか何か？オイラーサイクル？
そんなの簡単に見付ける方法あったかしら。完全グラフだと何かあるのかな。もう分からない。

無闇にDFSしたところで１本のパス（この場合サイクル？）になるような気がしないし。

## "2021-04-25 15-47-23"
うーん。

## "2021-04-27 00-33-50"
頂点数3で描いてみたら割と簡単な感じがする。行き先を文字列の末尾に追加していけば良いだけでは？
```
Input
32 2
Output
aabaabaabaabaabaabaabaabaabaabaa
Answer
aabbaabbaabbaabbaabbaabbaabbaabb
Checker Log
wrong answer the jury's answer is better than the participant's answer
```

駄目でした。

`a→a→b→a` で終わってしまってbbを使えない。

次の行き先を `a` から探すのが駄目？自己ループから始めたらAC。

何だったんだろうこの問題。
